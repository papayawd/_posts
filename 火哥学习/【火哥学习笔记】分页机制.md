---
title: 【火哥学习笔记】分页机制
date: 2021-07-10 22:00:00
tags: windows
---

​	<!-- more -->

[10-10-12 分页](#10-10-12 分页)

[2-9-9-12 分页](#2-9-9-12 分页)

## 10-10-12 分页

前置知识：线性地址、物理地址、以及文章`Windows内存管理概述`中的页式内存管理

对于每一个CUP核都有一个控制寄存器`CR3`指向了PDT表的首地址，也就是第一项·，之后的关系如下图：

![](https://i.loli.net/2021/07/11/WEXzMNaiSbUgR5y.png)

其中`PDE`与`PTE`详细拆解如下

![](https://i.loli.net/2021/07/11/pK6gfNHIc4ZM5nx.png)

`P`位：1表示目标页有效，0表示无效。这就需要`PDE`与`PTE`的P位同时为1才能访问到目标物理地址

`R/W`位：0表示可读，1表示可读可写，判断逻辑同P位

`U/S`位：0表示所有特权级`R0~R3`可以访问，1表示只有特权级`R0~R2`可以访问

`PWT`位与`PCD`位：忽略

`A`位：0表示该页未被访问，1表示已经被访问

`D`位：又称为`脏位`，0表示该页未被写过，1表示被写过

`PS`位：只存在于`PDE`中，0表示是小页，指向一个`PTT`表，1表示是一个大页，值为基址，线性地址剩下的位全部作为偏移（10-10-12分页中就是后22位都作为偏移）

`PAT`位：忽略

`G`位：刷新`TLB`的时候不会刷新`PDE/PTE`的G位为1的页 （`TLB`见下文）

`有效`位：忽略

有约定，线性地址`0xc0300000`解析出来指向`PDT`表的第一项，所以我们使用`0xc0300000 + k*4` 就可以获得第`k+1`项`PDE`的地址

有约定，线性地址`0xc0000000`解析出来指向第一个`PDE`指向的`PTT`表的第一项，所以我们使用`0xc0000000 + i*0x1000 + j*4`就可以得到第`i+1`项`PDE`指向的`PTT`表中的第`j+1`项`PTE`的地址

（具体解释见`挂载物理页(实验)`文章）

```cpp
kd> !dd 1a16a000  
#1a16a000 1a2a9867 19c98867 19f6f867 00000000
#1a16a010 1999c867 00000000 00000000 00000000
#1a16a020 00000000 00000000 00000000 00000000
#1a16a030 00000000 00000000 00000000 00000000
#1a16a040 00000000 00000000 00000000 00000000
#1a16a050 00000000 00000000 00000000 00000000
#1a16a060 00000000 00000000 00000000 00000000
#1a16a070 00000000 00000000 00000000 00000000
kd> !dd 1a16a000  + c00
#1a16ac00 1a16a863 1a26b863 00000000 0258e963
#1a16ac10 0258f963 02590963 02591963 02592963
#1a16ac20 02593963 02594963 02595963 02596963
#1a16ac30 02597963 02598963 02599963 0259a963
#1a16ac40 0259b963 0259c963 0259d963 0259e963
#1a16ac50 0259f963 025a0963 025a1963 025a2963
#1a16ac60 025a3963 025a4963 025a5963 025a6963
#1a16ac70 025a7963 025a8963 025a9963 025aa963
kd> !dd 1a16a000 + c00
#1a16ac00 1a16a863 1a26b863 00000000 0258e963
#1a16ac10 0258f963 02590963 02591963 02592963
#1a16ac20 02593963 02594963 02595963 02596963
#1a16ac30 02597963 02598963 02599963 0259a963
#1a16ac40 0259b963 0259c963 0259d963 0259e963
#1a16ac50 0259f963 025a0963 025a1963 025a2963
#1a16ac60 025a3963 025a4963 025a5963 025a6963
#1a16ac70 025a7963 025a8963 025a9963 025aa963
kd> !dd 1a16a000 + 0
#1a16a000 1a2a9867 19c98867 19f6f867 00000000
#1a16a010 1999c867 00000000 00000000 00000000
#1a16a020 00000000 00000000 00000000 00000000
#1a16a030 00000000 00000000 00000000 00000000
#1a16a040 00000000 00000000 00000000 00000000
#1a16a050 00000000 00000000 00000000 00000000
#1a16a060 00000000 00000000 00000000 00000000
#1a16a070 00000000 00000000 00000000 00000000

```



## 2-9-9-12 分页

2-9-9-12分页中每一个表项都是8字节，`CR3`寄存器指向了`PDPTT`表，也就是第一项`PDPTE`，线性地址到物理地址的方式和10-10-12分页的方法类似，细节有表项大小不同，以及多了一层的寻址。

2-9-9-12分页方式也使得寻址范围扩大到`64G`（`0xfffffffff`  9个f）

![](https://i.loli.net/2021/07/11/AjQJn3i5qRpfBZ1.png)

而`PDE`与`PTE`也有所变化，但是变化都不大

![](https://i.loli.net/2021/07/11/53emZQbgF1f9478.png)

`XD`标志位：1表示该页数据不可执行（被保护），0表示可执行

低12位是属性，同10-10-12分页中的属性

如图可以验证前面所说的寻址范围为`2^36 = 0xfffffffff` 

此外还有一点特殊的，就是第四张PDT表的前四项又分别指向了`PDPTT`表的前四项，如图

![](https://i.loli.net/2021/07/11/lGqCrWEDfewA4gH.png)

根据10-10-12分页对于`0xc0300000`地址的经验，我们可以推导出来2-9-9-12分页中，

而我们知道第4项`PDPTE`指向的`PDT`表的前4项`PDE`，又指向了前四个`PDPTE` 所以

使用`(0xC0000000 + 3*0x200000 + 3*0x1000) = (0xC0603000) + k*8 ` 就可以获得第`k+1`项`PDPTE`的地址

使用`(0xC0000000 + 3*0x200000) = (0xC0600000) + j*0x1000 + k*8 ` 就可以获得第`j+1`项`PDPTE`对应的第`k+1`项`PDE`的地址

使用`0xC0000000 + i*0x200000 + j*0x1000 + k*8 ` 就可以获得第`i+1`项`PDPTE`对应的第`j+1`项`PDE`对应的第`k+1`项`PTE`的地址

（`挂载物理页`实验成功，可以有力的说明以上结论是正确的）

但是在2-9-9-12分页模式下 这种`0xc0000000 + n`是无法得到`CR3`寄存器的值的

```cpp
kd> !dd 029402a0  
# 29402a0 14280801 00000000 14081801 00000000
# 29402b0 14342801 00000000 1437f801 00000000
# 29402c0 18b18801 00000000 18a99801 00000000
# 29402d0 18b1a801 00000000 18b17801 00000000
# 29402e0 f8a68300 00000000 19492801 00000000
# 29402f0 194d3801 00000000 19490801 00000000
# 2940300 f8a68320 00000000 00000000 00000000
# 2940310 00000000 00000000 00000000 00000000
kd> !dd 029402a0 + 3*8
# 29402b8 1437f801 00000000 18b18801 00000000
# 29402c8 18a99801 00000000 18b1a801 00000000
# 29402d8 18b17801 00000000 f8a68300 00000000
# 29402e8 19492801 00000000 194d3801 00000000
# 29402f8 19490801 00000000 f8a68320 00000000
# 2940308 00000000 00000000 00000000 00000000
# 2940318 00000000 00000000 f8a68340 00000000
# 2940328 00000000 00000000 00000000 00000000
kd> !dd 1437f000 + 3*8
#1437f018 1437f863 00000000 14103863 00000000
#1437f028 1401f863 00000000 00000000 00000000
#1437f038 0274e963 00000000 0274f963 00000000
#1437f048 02750963 00000000 02711963 00000000
#1437f058 02712963 00000000 02713963 00000000
#1437f068 02714963 00000000 02715963 00000000
#1437f078 02716963 00000000 02717963 00000000
#1437f088 02718963 00000000 02719963 00000000
kd> !dd 1437f000 + 0*8
#1437f000 14280863 00000000 14081863 00000000
#1437f010 14342863 00000000 1437f863 00000000
#1437f020 14103863 00000000 1401f863 00000000
#1437f030 00000000 00000000 0274e963 00000000
#1437f040 0274f963 00000000 02750963 00000000
#1437f050 02711963 00000000 02712963 00000000
#1437f060 02713963 00000000 02714963 00000000
#1437f070 02715963 00000000 02716963 00000000
kd> !dd 14280000 + 0
#14280000 14143867 00000000 14098867 00000000
#14280010 144f5867 00000000 00000000 00000000
#14280020 1464f867 00000000 142d7867 00000000
#14280030 00000000 00000000 00000000 00000000
#14280040 14382867 00000000 00000000 00000000
#14280050 00000000 00000000 00000000 00000000
#14280060 00000000 00000000 00000000 00000000
#14280070 00000000 00000000 00000000 00000000

```



## TLB与高速缓存

（看不懂英文 先留坑）https://www.sciencedirect.com/topics/computer-science/translation-lookaside-buffer