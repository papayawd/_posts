## 1.窗口

什么是消息：消息，就是指Windows发出的一个通知，告诉应用程序某个事情发生了。例如，单击鼠标、改变窗口尺寸、按下键盘上的一个键都会使Windows发送一个消息给应用程序，使其进行相应的处理。

平时的**控制台程序**都不需要用到消息，因为它只是与用户的标准输入流进行沟通。但是如果写了一个**有窗口**的程序，那么就有处理各种消息的要求了。

## 2.线程

一般的线程都是默默的在电脑里面运行，用户一般感受不到它的存在，但是当一个线程创建了一个窗口之后，用户就能直观感受到线程在运行了，此时这个线程也被称**GUI线程**。每个线程，如果它至少建立了一个窗口，都由系统对它分配一个消息队列。这个队列用于窗口消息的派送（Dispatch）。每个GUI线程都有独立的消息循环队列，GUI线程做的事情就是不停地接收消息（``GetMessage`），处理消息（`DispatchMessage`）。伪代码如下

```c
 MSG msg;
 while( GetMessage(&msg, NULL, 0, 0) )
 {
  TranslateMessage (&msg);
  DispatchMessage (&msg);
 }
```

直到接收到`WM_QUIT`消息时，`GetMessage`返回0，循环结束。

一个线程可以创建多个窗口，但是同一时间只能处理一个窗口的消息。如果一个窗口的父窗口被关闭，那么这个窗口也会被关闭，就类似子线程依赖父线程一样。

## 3.消息

### 消息队列种类

消息队列结构如下

```c

typedef struct _USER_MESSAGE_QUEUE  //线程的消息队列描述符
 
{
 
  LONG References;//本队列的引用计数
 
  struct _ETHREAD *Thread;//本队列的所属线程
 
  LIST_ENTRY SentMessagesListHead;//通过SendMessage方式发来的消息进入这个队列（send队列）
 
  LIST_ENTRY PostedMessagesListHead; //通过PostMessage方式发来的消息进入这个队列（post队列）
 
  LIST_ENTRY NotifyMessagesListHead;//专用于存放SendMessage回调函数调用通知的消息队列
 
  LIST_ENTRY HardwareMessagesListHead;//来自硬件设备的消息（指鼠标消息）队列
 
  // ...... 省略
 
} USER_MESSAGE_QUEUE, *PUSER_MESSAGE_QUEUE;
```

windows给消息队列划分了四个不同种类，三个常用的为`SentMessagesListHead`，`PostedMessagesListHead`，`HardwareMessagesListHead`，需要注意的是**键盘消息**是`PostMessage`。

用户使用`GetMessage`，调用内核的`NtUserGetMessage`

`NtUserGetMessage` 先尝试调用带`REMOVE`参数的`co_IntPeekMessage`来获取消息， 没有得到消息就调用 `co_IntWaitMessage`来一直等待

`co_IntPeekMessage` 带的参数有一个为 `RemoveMsg `表示该次去除的消息要不要舍去。 它里面调用`co_MsqDispatchOneSentMessage`把所有的send类型的消息一个一个Dispatch了，然后使用带参数为**FALSE**的`co_MsqFindMessage` 查看post消息列表里面是否有对应的消息，没有的话继续使用带参数为**TRUE**的`co_MsqFindMessage` 查看硬件消息列表里面是否有对应的消息。以上查询过程会消耗一段时间，所以可能又积累了sent消息 又调用`co_MsqDispatchOneSentMessage`处理。接下来就是寻找键盘鼠标消息、重绘消息、定时器消息。

`co_IntWaitMessage`如其名就是一个等待消息出现的函数，等待的类型为

```c
PVOID WaitObjects[2] = {MessageQueue->NewMessages, &HardwareMessageEvent};
```

`NewMessages`是`PostMessage`之后产生的事件，`HardwareMessageEvent`就是硬件消息事件了。

以上操作可以说明：每当有新消息进队时，就会从`co_IntWaitMessage`回到`NtUserGetMessage`内部继续执行`co_IntPeekMessage`函数，它会两次调用`co_MsqFindMessage`，分别查找线程post队列和硬件消息队列，并且调用前后都会Dispatch掉send消息。意思是查找到返回的都是post消息或者硬件消息，send消息就像`APC`消息一样很高频率地被Dispatch处理掉。

## 参考博客

https://blog.csdn.net/weiwangchao_/article/details/7262891  

https://blog.csdn.net/jadeshu/article/details/85057709



