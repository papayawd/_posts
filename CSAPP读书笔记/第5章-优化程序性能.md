# 5. 优化程序性能

## 5.1 优化编译器的能力和局限性

两个指针可能只想同一个内存位置的情况叫做**内存别名使用**，这是一个妨碍优化的因素。

用**内联函数**替换优化函数调用：即把函数直接抽取出来放在调用函数的位置，减少了入栈出栈等操作以提高程序性能。虽然这种做法有违背分布式编写，但是优化过程是程序员不可见的，对于开发来说还是很不错的。此外内联函数优化只能对于非递归函数使用。

## 5.4 消除循环的低效率

**代码移动**：这类优化包括识别要执行多次（比如循环里的）但是计算结果不会改变的计算。比如

```c
for(int i=0;i<strlen(s);i++);
// 改写为
int len = strlen(s);
for(int i=0;i<len;i++);
```

这种优化编译器会十分小心，会确保s的`\0`结束符没有被修改或者是中间是否有添加`\0`结束符。

## 5.5 消除不必要的内存引用

```c
void combine3(vec_ptr v,data_t *dest)
{
    long i;
    long length = vec_length(v);
    data_t *data = get_vec_start(v);
    for(i = 0; i < length; i++)
    {
        *dest = *dest OP data[i];
    }
}
```



```c
void combine4(vec_ptr v,data_t *dest)
{
    long i;
    long length = vec_length(v);
    data_t *data = get_vec_start(v);
    data_t acc = IDENT;
    for(i = 0; i < length; i++)
    {
        acc = acc OP data[i];
    }
    *dest = acc;
}
```

对比`combine3`和`combine4`，前者每次计算出结果之后都要重新将新的结果写回内存，下一次计算的时候又从内存中拿出刚写入的值，这样读写很浪费。解决方法是后者一样把结果放入到一个临时变量中，计算结束后再写入内存。

## 5.8 循环展开

**循环展开**是一种程序变换，通过增加每次迭代计算的元素数量，减少循环的迭代次数。它减少了不直接有助于程序结果的操作的数量，例如循环索引计算和条件分支；还提供了一些方法可以进一步变化代码，减少整个计算中**关键路径**上的操作数量。

```c
void combine5(vec_ptr v,data_t *dest)
{
    long i;
    long length = vec_length(v);
    data_t *data = get_vec_start(v);
    data_t acc = IDENT;
    for(i = 0; i < length; i++)
    {
        acc = acc OP data[i]; // old method
    }
    
	for(i = 0; i < length; i += 2) // 减少迭代次数
    {
        acc = acc OP data[i] OP data[i+1]; // 循环展开  2 x 1 展开
    }
    *dest = acc;
}
```

## 5.9 提高并行性

执行整数加法和乘法的功能单元是完全流水线化的，意味着它们可以每个时钟周期开始一个新的操作，并且有些操作可以被多个功能单元执行。

由此可以通过将一组合并运算分割成两个或者更多部分，并在最后合并结果来提高性能。称为**多路并行**

```c
void combine5(vec_ptr v,data_t *dest)
{
    long i;
    long length = vec_length(v);
    data_t *data = get_vec_start(v);
    data_t acc0 = IDENT;
    data_t acc1 = IDENT;
    for(i = 0; i < length; i += 2) // 循环展开
    {
        acc0 = acc0 OP data[i];  // 两路并行
        acc1 = acc1 OP data[i+1]; // 2 x 2 展开 循环展开 与 两路并行 同时
    }
    *dest = acc0 OP acc1 ;
}
```

当我们做`k x k`展开，且k足够大的时候可以几乎达到吞吐量界限，但是仍要考虑是否保留了原始程序的功能。

另一点，浮点数的加法与乘法不是可结合的，是浮点数运算四舍五入或者溢出的原因。但是往往误差在我们能够接受的范围内，使得性能翻倍要比冒险产生奇怪数据导致不同结果的风险更重要。 仍然大多数编译器并不会尝试对浮点数进行这种优化。

此外还有**重新组合**的方法，能够减少计算中关键路径上的操作数量，通过更好的利用功能单元的流水线能力得到更好的性能。

```c
acc = (acc OP data[i]) OP data[i+1];
// 重新组合一下
acc = acc OP (data[i] OP data[i+1]);
```

## 5.11 一些限制因素

### 5.11.1 寄存器溢出

循环并行性的好处受汇编代码描述计算的能力限制。如果并行度p超过了可用的寄存器数量，那么编译器会诉诸**溢出**，将某些之临时存放在内存中去，通常是堆栈上，而因内存读写增加运行时间。

### 5.11.2 分支预测和预测错误处罚

在一个使用**投机执行**的处理器，他会避免修改任何实际的寄存器或内存位置，知道确定了实际的结果。如果预测正确，处理器就会“提交”投机执行的指令的结果，把他们储存到寄存器或内存。如果预测错误，处理器就要丢弃所有投机执行的结果，在正确的位置重新开始执行。这样做会引起很大的预测错误处罚。

在最近的`x86-64`的处理器有**条件传送指令**，条件传送指令可以被实现为普通指令流水线化处理的一部分，没有必要猜测条件是否满足，因此也没有预测错误处罚。如下：

```c
long absdiff(long x,long y)
{
    long result;
    if(x < y) 
        result = y - x;
    else 
        result = x - y;
   	return result;
}
```

```c
long cmovdiff(long x,long y)
{
    long rval = y - x;
    long eval = x - y;
    long ntest = x >= y; // 使用条件赋值来实现
    if(ntest) rval = eval;
   	return eval;
}
```

这样的控制流不依赖于数据，这使得处理器更容易保持流水线是满的。

两点关于分支预测的通用原则：1.不要过分关心可预测的分支、2.**书写适合用条件传送实现的代码**。

## 5.12 理解内存性能

### 5.12.1 加载的性能

考虑一条汇编指令`mov rdi, [rdi]`，寄存器`rdi`的每个值都依赖于加载操作的完成，而加载操作又以`rdi`中的值作为它的地址，因此直到前一次迭代的加载操作完成，下一次迭代的加载操作才能开始。

### 5.12.2 储存的性能

储存操作并不影响任何寄存器值。但是会出现一种称为**写/读相关**的情况---一个内存读的结果依赖于一个最近的内存写

```c
void write_read(long* src, long* dst, long n)
{
    long cnt = n;
    long val = 0;
    while (cnt)
    {
        *dst = val;
        val = (*src) + 1; // 当src和dst相等时，存储和加载之间相互影响
        cnt --;
    }
}
```

首先需要了解接在和存储的执行单元。存储单元包含一个**存储缓冲区**，它包含已经被发射到存储单元而又还没有完成的存储操作的地址和数据，这里的完成包括更新数据告诉缓存。意思是存储缓冲区的优先级大于**高速缓存**。当一个加载操作发生的时候，首先必须检查存储缓存区中有没有匹配的地址，然后去检查高速缓存，最后才是直接去内存取值。

如果上面代码中，`src`和`dst`相等，加载操作就必须等待到，在它之前的存储操作将结果存放在存储缓存区中，此时关键路径就是加载与存储相关的代码了，这就是**写/读相关**产生的延迟了。

## 5.14 确认和消除性瓶颈

### 5.14.1 程序剖析

使用到了`Unix`中的剖析程序`GPROF`

```c
// example1.c
#include <stdio.h>
long long  a(void) {
  long long  i=0,g=0;
  while(i++<1000000000L)
  {
     g+=i;
  }
  return g;
}
long long  b(void) {
  long long i=0,g=0;
  while(i++<4000000000L)
  {
    g+=i;
  }
  return g;
}
int main()
{
   int iterations;
    printf("%lld %lld\n",a(),b());
    return 0;
}
```

```shell
# shell
gcc example1.c -pg -o example1
./example1
# 此时会生成一个gmon.out文件
gprof example1 gmon.out -p
```

```shell
# output
Flat profile:

Each sample counts as 0.01 seconds.
  %   cumulative   self              self     total           
 time   seconds   seconds    calls   s/call   s/call  name    
 79.94      5.64     5.64        1     5.64     5.64  b
 21.75      7.18     1.54        1     1.54     1.54  a
# gprof 计时不是很准确
```

