# 4. 处理器体系结构

## 4.3  Y86-64的顺序实现

取值、译码、执行、访存、写回、更新PC

## 4.4 流水线的通用原理

流水线化的一个重要特性就是提高了系统的吞吐量(throughput)，也就是单位时间内处理的指令个数。不过也会轻微地增加延迟，也就是处理一条指令所需要的时间。

减缓时钟不会影响流水线的行为，直到时钟上升的时候才会改变寄存器状态，相反时钟过快可能会存在来不及通过组合逻辑的情况，以至于寄存器的输入还不是合法的值。

流水线也有局限性：

1.**不一致的划分**。如果处理各种指令的时间，本来就存在极大的差距，那么经过流水线的时候就会存在很多时间空隙，处理器没有得到完全的利用，造成时间浪费。

2.**流水线过深，收益反而下降**。

## 4.5  Y86-64流水线的实现

### 4.5.4 预测下一个PC

每个时钟周期都需要有一条新的指令进入取值阶段，所以每当一个时间周期结束，就需要确定下一条指令的位置。比较棘手的是如果取出的当前指令是条件分支指令，或者是`jmp eax`这样的指令，就需要对下一条指令的地址进行预测，并且承担预测失败带来的损失。（目前的处理器大部分情况下都能预测正确）

### 4.5.5 流水线冒险

流水线存在**数据冒险**和**控制冒险**。

数据冒险就是当前需要使用的数据可能正在流水线的某个部分而没有执行结束，导致使用数据的时候并且不是拿到我们想要的值。

要处理数据冒险有以下几种方法：

1.**用暂停来避免数据冒险**，让一条指令停顿在译码阶段，知道产生它的源操作数的指令通过了写回阶段。但是这样做之后得到的处理器性能并不很好，因为经常会有暂停出现。

2.**用转发来避免数据冒险**，将结果值直接从一个流水线阶段传到较早的阶段的技术称为**数据转发**，有时称为**旁路**。直接使用转发的值，而不需要等待结果值被写入再去寄存器文件读取，使流水线不需要任何暂停。

3.暂停与转发结合，应对**加载/使用数据冒险**的情况，即上一条指令从内存中读取某值，下一条指令需要该值作为操作数。

控制冒险则是前面提到的PC预测。

### 4.5.6 异常处理

异常处理中有一些细节问题需要去解决：

一、由于流水线的存在，可能同时存在多条指令异常，比如取值阶段中有halt指令，同时访存阶段有数组越界的问题。

​			对于这种情况的处理方式是：**由流水线中最深的指令引起的异常，优先级最高**。

二、取出一条指令，开始执行的时候导致了一个异常，后来因为分支预测错误，取消了该指令。

三、因为流水线化的处理器会在不同阶段更新系统状态的不同部分。比如一条指令导致了一个异常，他后面的指令在异常指令完成之前改变了部分状态。

对于二、三点细节，处理方式是：会在每个流水线寄存器中包括一个**状态码stat**。如果一条指令在其处理中于某个阶段产生了一个异常，这给字段就被设置为指示异常的种类。

异常状态和该指令的其他信息一起沿着流水线传播，直到到达它的**写回**阶段，流水线控制逻辑发现出现了异常，并且停止执行。

为了避免异常指令之后的指令更新任何程序员可见的状态，当处于访存或写回阶段中的指令导致异常时，流水线控制逻辑必须**禁止**更新条件码寄存器或者是数据内存。

异常事件不会对流水线中的指令流由任何影响，除了会**禁止**流水线中后面的指令更新程序员的可见状态（条件码寄存器和内存）。

如果取出了某条指令，过后又取消了，那么所有关于这条指令的异常状态信息也都会被取消。**携带指令的异常状态以及所有其他信息通过流水线**的简单原则是处理异常的简单而可靠的机制



